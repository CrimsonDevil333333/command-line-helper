// Tests
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_id_from_url_extraction_short() {
        let url = "https://www.youtube.com/watch?v=Bn40gUUd5m0";
        let id = get_video_id(url);

        assert!(id.is_some());
        assert_eq!(id.unwrap(), "Bn40gUUd5m0");
    }

    #[test]
    fn test_get_video_info() {
        let url = "https://www.youtube.com/watch?v=zCLOJ9j1k2Y";
        let info = get_video_info(url);

        assert!(info.is_ok());
    }

    #[test]
    fn test_get_video_download_url() {
        let url = "https://www.youtube.com/watch?v=zCLOJ9j1k2Y";
        let video_info = get_video_info(url).unwrap();
        let url = get_video_download_url(&video_info);

        assert!(url.is_some());
    }

    #[test]
    fn test_file_download() {
        let url = "https://www.youtube.com/watch?v=Bn40gUUd5m0";
        let video_info = get_video_info(url).unwrap();
        let url = get_video_download_url(&video_info);
        let file_name =
            get_video_file_name(&video_info).expect("filename in video_info is present");

        download_file(url.unwrap(), &file_name).unwrap();

        assert!(Path::new(&file_name).exists());
    }
}

// get video id function
fn get_video_id(url: &str) -> Option<&str> {
    regex::Regex::new(r"https://www\.youtube\.com/watch\?v=(.*)")
        .ok()?
        .captures(url)?
        .get(1)
        .map(|id| id.as_str())
}

fn get_video_info(url: &str) -> Result<Value> {
    if let Some(id) = get_video_id(url) {
        let video_url = format!(
            "https://www.youtube.com/youtubei/v1/player?key=YOUR_API_KEY", // Replace YOUR_API_KEY with your actual YouTube API key
        );

        let json_payload = format!(
            r#"{{
                "context": {{
                    "client": {{
                        "hl": "en",
                        "clientName": "WEB",
                        "clientVersion": "2.20210721.00.00",
                        "clientFormFactor": "UNKNOWN_FORM_FACTOR",
                        "clientScreen": "WATCH",
                        "mainAppWebInfo": {{
                            "graftUrl": "/watch?v={}",
                        }}
                    }},
                    "user": {{
                        "lockedSafetyMode": false
                    }},
                    "request": {{
                        "useSsl": true,
                        "internalExperimentFlags": [],
                        "consistencyTokenJars": []
                    }}
                }},
                "videoId": "{}",
                "playbackContext": {{
                    "contentPlaybackContext": {{
                        "vis": 0,
                        "splay": false,
                        "autoCaptionsDefaultOn": false,
                        "autonavState": "STATE_NONE",
                        "html5Preference": "HTML5_PREF_WANTS",
                        "lactMilliseconds": "-1"
                    }}
                }},
                "racyCheckOk": false,
                "contentCheckOk": false
            }}"#,
            id, id
        );

        let client = reqwest::blocking::Client::new();
        let response = client
            .post(&video_url)
            .header("Content-Type", "application/json")
            .body(json_payload)
            .send()
            .context("Failed to send POST request")?;

        let res_body = response.text().context("Failed to get video info")?;

        // Parse the JSON string into a serde_json::Value
        let parsed_json: Result<Value, _> = serde_json::from_str(res_body.as_str());

        match parsed_json {
            Ok(json_value) => {
                if let Some(streaming_data) = json_value["streamingData"].as_object() {
                    let streaming_value: Value = serde_json::Value::Object(streaming_data.clone());
                    println!("Streaming Value: {}", serde_json::to_string_pretty(&streaming_value).unwrap());
                    Ok(streaming_value)
                } else {
                    Err(anyhow::anyhow!("No 'streamingData' field found in the JSON."))
                }
            }
            Err(e) => Err(anyhow::anyhow!("Error parsing JSON: {}", e)),
        }
    } else {
        Err(anyhow::anyhow!("couldn't get video id"))
    }
}




fn get_video_download_url(video_info: &serde_json::Value) -> Option<&str> {
    let mp4_codec_regex = regex::Regex::new(r"codecs=(.*mp4.*)").ok()?;
    for t in video_info["streamingData"]["formats"].as_array()? {
        if let Some("360p") = t["qualityLabel"].as_str() {
            if mp4_codec_regex.is_match(t["mimeType"].as_str().unwrap_or_default()) {
                return t["url"].as_str();
            }
        }
    }
    None
}

fn get_video_file_name(video_info: &Value) -> Option<String> {
    video_info["videoDetails"]["title"]
        .as_str()
        .map(|name| format!("{}.mp4", name))
}

fn download_file(url: &str, file_name: &str) -> Result<()> {
    let url = Url::from_str(url).context("Failed to parse URL")?;
    let mut resp = Client::new().get(url.as_str()).send()?;
    let mut out = File::create(file_name)?;

    io::copy(&mut resp, &mut out).context("Failed to copy data from response to file")?;

    Ok(())
}
